===================================================
SPEC: RES-PASO7-MATCH
Modulo Match - Conectar Clientes con Propiedades
Fecha: 2026-01-18
Por: C1 Sleepy
===================================================

OBJETIVO:
Conectar clientes del CRM con propiedades del inventario.
Matchmaking basado en criterios del cliente.

===================================================
CREAR: app/components/MatchTab.jsx
===================================================

```javascript
'use client'
import { useState, useEffect } from 'react'

export default function MatchTab({ t, lang }) {
  const [clients, setClients] = useState([])
  const [properties, setProperties] = useState([])
  const [selectedClient, setSelectedClient] = useState(null)
  const [clientCriteria, setClientCriteria] = useState(null)
  const [matches, setMatches] = useState([])
  const [showCriteriaForm, setShowCriteriaForm] = useState(false)

  useEffect(() => {
    const savedClients = localStorage.getItem('res_clients')
    const savedProperties = localStorage.getItem('res_properties')
    const savedCriteria = localStorage.getItem('res_client_criteria')
    
    if (savedClients) setClients(JSON.parse(savedClients))
    if (savedProperties) setProperties(JSON.parse(savedProperties))
    if (savedCriteria) setClientCriteria(JSON.parse(savedCriteria))
  }, [])

  const saveCriteria = (criteria) => {
    const updated = { ...clientCriteria, [selectedClient.id]: criteria }
    setClientCriteria(updated)
    localStorage.setItem('res_client_criteria', JSON.stringify(updated))
  }

  const getCriteria = (clientId) => {
    return clientCriteria?.[clientId] || null
  }

  const calculateMatch = (property, criteria) => {
    if (!criteria) return 0
    let score = 0
    let factors = 0

    // Budget match (40%)
    if (criteria.budgetMin || criteria.budgetMax) {
      factors += 40
      const price = property.precio ? parseFloat(property.precio) : 0
      if (price >= (criteria.budgetMin || 0) && price <= (criteria.budgetMax || Infinity)) {
        score += 40
      } else if (price < (criteria.budgetMin || 0)) {
        const diff = ((criteria.budgetMin - price) / criteria.budgetMin) * 100
        score += Math.max(0, 40 - diff)
      } else {
        const diff = ((price - criteria.budgetMax) / criteria.budgetMax) * 100
        score += Math.max(0, 40 - diff)
      }
    }

    // Type match (20%)
    if (criteria.propertyTypes?.length > 0) {
      factors += 20
      if (criteria.propertyTypes.includes(property.tipo)) {
        score += 20
      }
    }

    // Bedrooms match (15%)
    if (criteria.minBedrooms) {
      factors += 15
      const beds = parseInt(property.recamaras) || 0
      if (beds >= criteria.minBedrooms) {
        score += 15
      } else if (beds === criteria.minBedrooms - 1) {
        score += 8
      }
    }

    // Zone match (15%)
    if (criteria.preferredZones?.length > 0) {
      factors += 15
      if (criteria.preferredZones.some(z => property.zona?.toLowerCase().includes(z.toLowerCase()))) {
        score += 15
      }
    }

    // Amenities match (10%)
    if (criteria.requiredAmenities?.length > 0) {
      factors += 10
      const propAmenities = property.amenidades?.toLowerCase() || ''
      const matched = criteria.requiredAmenities.filter(a => propAmenities.includes(a.toLowerCase())).length
      score += (matched / criteria.requiredAmenities.length) * 10
    }

    return factors > 0 ? Math.round((score / factors) * 100) : 0
  }

  const findMatches = () => {
    if (!selectedClient) return
    
    const criteria = getCriteria(selectedClient.id)
    if (!criteria) {
      setShowCriteriaForm(true)
      return
    }

    const availableProps = properties.filter(p => p.estatus === 'disponible')
    const scored = availableProps.map(p => ({
      ...p,
      matchScore: calculateMatch(p, criteria)
    }))
    .filter(p => p.matchScore > 0)
    .sort((a, b) => b.matchScore - a.matchScore)
    .slice(0, 10)

    setMatches(scored)
  }

  const formatPrice = (precio, moneda) => {
    if (!precio) return '-'
    const num = parseFloat(precio).toLocaleString()
    return moneda === 'USD' ? `$${num} USD` : `$${num} MXN`
  }

  // No clients or properties
  if (clients.length === 0 || properties.length === 0) {
    return (
      <div className="text-center py-8">
        <p className="text-white/60 mb-4">{t.needData}</p>
        <p className="text-white/40 text-sm">
          {clients.length === 0 && t.addClients}
          {clients.length > 0 && properties.length === 0 && t.addProperties}
        </p>
      </div>
    )
  }

  // Criteria Form
  if (showCriteriaForm && selectedClient) {
    return (
      <CriteriaForm 
        t={t}
        client={selectedClient}
        initialCriteria={getCriteria(selectedClient.id)}
        onSave={(criteria) => {
          saveCriteria(criteria)
          setShowCriteriaForm(false)
          findMatches()
        }}
        onCancel={() => setShowCriteriaForm(false)}
      />
    )
  }

  // Match Results
  if (matches.length > 0 && selectedClient) {
    return (
      <div className="space-y-4">
        <div className="flex justify-between items-center">
          <button
            onClick={() => { setMatches([]); setSelectedClient(null) }}
            className="text-white/60 hover:text-white"
          >
            ‚Üê {t.back}
          </button>
          <button
            onClick={() => setShowCriteriaForm(true)}
            className="text-white/60 hover:text-white text-sm"
          >
            ‚öôÔ∏è {t.editCriteria}
          </button>
        </div>

        <div className="bg-blue-500/20 rounded-xl p-3">
          <p className="text-white font-medium">{selectedClient.nombre}</p>
          <p className="text-white/60 text-sm">{matches.length} {t.matchesFound}</p>
        </div>

        <div className="space-y-3">
          {matches.map(prop => (
            <div key={prop.id} className="bg-white/10 rounded-xl p-4">
              <div className="flex justify-between items-start">
                <div className="flex-1">
                  <div className="flex items-center gap-2 mb-1">
                    <span className={`text-xs px-2 py-0.5 rounded-full ${
                      prop.matchScore >= 80 ? 'bg-green-500/30 text-green-300' :
                      prop.matchScore >= 50 ? 'bg-yellow-500/30 text-yellow-300' :
                      'bg-red-500/30 text-red-300'
                    }`}>
                      {prop.matchScore}% {t.match}
                    </span>
                    <span className={`text-xs px-2 py-0.5 rounded-full ${
                      prop.listingType === 'pocket' 
                        ? 'bg-purple-500/30 text-purple-300' 
                        : 'bg-blue-500/30 text-blue-300'
                    }`}>
                      {prop.listingType === 'pocket' ? 'üîí' : 'üìã'}
                    </span>
                  </div>
                  <p className="text-white font-medium">{prop.titulo}</p>
                  <p className="text-white/60 text-sm">{prop.zona}</p>
                  <p className="text-white/50 text-sm">
                    {prop.recamaras && `${prop.recamaras} ${t.beds}`}
                    {prop.banos && ` ‚Ä¢ ${prop.banos} ${t.baths}`}
                    {prop.m2Construccion && ` ‚Ä¢ ${prop.m2Construccion}m¬≤`}
                  </p>
                </div>
                <div className="text-right">
                  <p className="text-white font-bold">{formatPrice(prop.precio, prop.moneda)}</p>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>
    )
  }

  // Client Selection
  return (
    <div className="space-y-4">
      <p className="text-white/60 text-sm">{t.selectClient}</p>
      
      <div className="space-y-2">
        {clients.map(client => {
          const hasCriteria = !!getCriteria(client.id)
          return (
            <div
              key={client.id}
              onClick={() => setSelectedClient(client)}
              className={`bg-white/10 rounded-xl p-4 cursor-pointer hover:bg-white/20 transition-all ${
                selectedClient?.id === client.id ? 'ring-2 ring-white/40' : ''
              }`}
            >
              <div className="flex justify-between items-center">
                <div>
                  <p className="text-white font-medium">{client.nombre}</p>
                  <p className="text-white/60 text-sm">{client.tel} ‚Ä¢ {client.email}</p>
                </div>
                <div className="flex items-center gap-2">
                  {hasCriteria && (
                    <span className="text-xs bg-green-500/30 text-green-300 px-2 py-0.5 rounded-full">
                      ‚úì {t.hasCriteria}
                    </span>
                  )}
                </div>
              </div>
            </div>
          )
        })}
      </div>

      {selectedClient && (
        <button
          onClick={findMatches}
          className="w-full bg-green-500/80 hover:bg-green-500 text-white font-bold py-3 rounded-xl transition-all"
        >
          üîç {t.findMatches}
        </button>
      )}
    </div>
  )
}

function CriteriaForm({ t, client, initialCriteria, onSave, onCancel }) {
  const [criteria, setCriteria] = useState(initialCriteria || {
    budgetMin: '',
    budgetMax: '',
    propertyTypes: [],
    minBedrooms: '',
    preferredZones: [],
    requiredAmenities: [],
    notes: '',
  })

  const propertyTypes = ['casa', 'depto', 'terreno', 'local']
  const zones = ['Marina Vallarta', 'Zona Romantica', 'Bucerias', 'Nuevo Vallarta', 'Sayulita', 'Punta Mita']
  const amenities = ['Alberca', 'Vista Mar', 'Amueblado', 'Seguridad', 'Gym']

  const toggleArray = (field, value) => {
    setCriteria(prev => ({
      ...prev,
      [field]: prev[field].includes(value)
        ? prev[field].filter(v => v !== value)
        : [...prev[field], value]
    }))
  }

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <button onClick={onCancel} className="text-white/60 hover:text-white">
          ‚Üê {t.back}
        </button>
        <h3 className="text-white font-medium">{t.criteriaFor} {client.nombre}</h3>
        <div />
      </div>

      {/* Budget */}
      <div>
        <label className="block text-white/70 text-sm mb-2">{t.budget} (USD)</label>
        <div className="flex gap-2">
          <input
            type="number"
            placeholder="Min"
            value={criteria.budgetMin}
            onChange={e => setCriteria(prev => ({ ...prev, budgetMin: e.target.value }))}
            className="flex-1 bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-white"
          />
          <span className="text-white/40 self-center">-</span>
          <input
            type="number"
            placeholder="Max"
            value={criteria.budgetMax}
            onChange={e => setCriteria(prev => ({ ...prev, budgetMax: e.target.value }))}
            className="flex-1 bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-white"
          />
        </div>
      </div>

      {/* Property Types */}
      <div>
        <label className="block text-white/70 text-sm mb-2">{t.propertyTypes}</label>
        <div className="flex flex-wrap gap-2">
          {propertyTypes.map(type => (
            <button
              key={type}
              type="button"
              onClick={() => toggleArray('propertyTypes', type)}
              className={`px-3 py-1 rounded-full text-sm capitalize ${
                criteria.propertyTypes.includes(type)
                  ? 'bg-white/30 text-white'
                  : 'bg-white/10 text-white/60'
              }`}
            >
              {type}
            </button>
          ))}
        </div>
      </div>

      {/* Min Bedrooms */}
      <div>
        <label className="block text-white/70 text-sm mb-2">{t.minBedrooms}</label>
        <input
          type="number"
          value={criteria.minBedrooms}
          onChange={e => setCriteria(prev => ({ ...prev, minBedrooms: e.target.value }))}
          min="0"
          className="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-white"
        />
      </div>

      {/* Preferred Zones */}
      <div>
        <label className="block text-white/70 text-sm mb-2">{t.preferredZones}</label>
        <div className="flex flex-wrap gap-2">
          {zones.map(zone => (
            <button
              key={zone}
              type="button"
              onClick={() => toggleArray('preferredZones', zone)}
              className={`px-3 py-1 rounded-full text-sm ${
                criteria.preferredZones.includes(zone)
                  ? 'bg-white/30 text-white'
                  : 'bg-white/10 text-white/60'
              }`}
            >
              {zone}
            </button>
          ))}
        </div>
      </div>

      {/* Required Amenities */}
      <div>
        <label className="block text-white/70 text-sm mb-2">{t.requiredAmenities}</label>
        <div className="flex flex-wrap gap-2">
          {amenities.map(amenity => (
            <button
              key={amenity}
              type="button"
              onClick={() => toggleArray('requiredAmenities', amenity)}
              className={`px-3 py-1 rounded-full text-sm ${
                criteria.requiredAmenities.includes(amenity)
                  ? 'bg-white/30 text-white'
                  : 'bg-white/10 text-white/60'
              }`}
            >
              {amenity}
            </button>
          ))}
        </div>
      </div>

      {/* Notes */}
      <div>
        <label className="block text-white/70 text-sm mb-2">{t.notes}</label>
        <textarea
          value={criteria.notes}
          onChange={e => setCriteria(prev => ({ ...prev, notes: e.target.value }))}
          rows={2}
          className="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-white resize-none"
        />
      </div>

      <button
        onClick={() => onSave(criteria)}
        className="w-full bg-green-500/80 hover:bg-green-500 text-white font-bold py-3 rounded-xl transition-all"
      >
        üíæ {t.saveCriteria}
      </button>
    </div>
  )
}
```

===================================================
AGREGAR TRADUCCIONES en app/page.js
===================================================

En translations.es agregar:

```javascript
match: {
  back: 'Volver',
  needData: 'Necesitas agregar clientes y propiedades primero',
  addClients: 'Ve a Clientes para agregar clientes',
  addProperties: 'Ve a Inventario para agregar propiedades',
  selectClient: 'Selecciona un cliente para buscar propiedades',
  hasCriteria: 'Criterios',
  findMatches: 'Buscar Propiedades',
  matchesFound: 'propiedades encontradas',
  match: 'match',
  beds: 'rec',
  baths: 'ba√±os',
  editCriteria: 'Editar Criterios',
  criteriaFor: 'Criterios para',
  budget: 'Presupuesto',
  propertyTypes: 'Tipos de Propiedad',
  minBedrooms: 'M√≠nimo Rec√°maras',
  preferredZones: 'Zonas Preferidas',
  requiredAmenities: 'Amenidades Requeridas',
  notes: 'Notas',
  saveCriteria: 'Guardar Criterios',
},
```

En translations.en agregar:

```javascript
match: {
  back: 'Back',
  needData: 'You need to add clients and properties first',
  addClients: 'Go to Clients to add clients',
  addProperties: 'Go to Inventory to add properties',
  selectClient: 'Select a client to find properties',
  hasCriteria: 'Criteria',
  findMatches: 'Find Properties',
  matchesFound: 'properties found',
  match: 'match',
  beds: 'bed',
  baths: 'bath',
  editCriteria: 'Edit Criteria',
  criteriaFor: 'Criteria for',
  budget: 'Budget',
  propertyTypes: 'Property Types',
  minBedrooms: 'Min Bedrooms',
  preferredZones: 'Preferred Areas',
  requiredAmenities: 'Required Amenities',
  notes: 'Notes',
  saveCriteria: 'Save Criteria',
},
```

===================================================
MODIFICAR: app/page.js - Agregar import y uso
===================================================

1. Agregar import:
```javascript
import MatchTab from './components/MatchTab'
```

2. En el area de contenido:
```javascript
{activeTab === 'clientes' && <ClientesTab t={t.clientes} />}
{activeTab === 'inventario' && <InventarioTab t={t.inventario} />}
{activeTab === 'comps' && <CompsTab t={t.comps} lang={lang} />}
{activeTab === 'match' && <MatchTab t={t.match} lang={lang} />}
```

===================================================
ALGORITMO DE MATCH
===================================================

Ponderacion:
- Presupuesto: 40% (dentro del rango = 100%, fuera = proporcional)
- Tipo propiedad: 20% (match exacto)
- Recamaras: 15% (>= minimo = 100%, -1 = 50%)
- Zona: 15% (match parcial por nombre)
- Amenidades: 10% (proporcion de requeridas encontradas)

Score final = suma ponderada / factores activos * 100

===================================================
CRITERIO DE EXITO
===================================================

[ ] Lista de clientes muestra badge si tiene criterios
[ ] Seleccionar cliente y click "Buscar"
[ ] Si no hay criterios, abre formulario
[ ] Formulario guarda en localStorage
[ ] Resultados muestran propiedades ordenadas por match %
[ ] Score verde >80%, amarillo 50-80%, rojo <50%
[ ] Muestra badge Listed/Pocket
[ ] Boton editar criterios funciona
[ ] Bilingue ES/EN

===================================================
COMMIT
===================================================

"feat: add Match module - connect clients with properties"

===================================================
FIN RES-PASO7-MATCH
===================================================


===================================================
LEGAL-SOLUTIONS-FIX-001
Caso Detalle Page Fixes
De: C1 (Sleepy) | Para: Cloud Claude
Fecha: 2026-01-18
===================================================

ARCHIVO PRINCIPAL: src/app/casos/[id]/page.tsx

---------------------------------------------------
FIX 1: AUDIENCIAS - Agregar funcionalidad
---------------------------------------------------

ANTES:
<button className="text-blue-600 text-sm font-medium hover:underline">+ Agregar</button>

DESPU√âS:
<Link href={`/agenda?caseId=${caseData.id}&action=new`} className="text-blue-600 text-sm font-medium hover:underline">+ Agregar</Link>

---------------------------------------------------
FIX 2: VER CLIENTE - Navegaci√≥n de regreso
---------------------------------------------------

ANTES:
<Link href={`/clientes/${caseData.client.id}`} ...>Ver cliente ‚Üí</Link>

DESPU√âS:
<Link href={`/clientes/${caseData.client.id}?from=casos&caseId=${caseData.id}`} ...>Ver cliente ‚Üí</Link>

ARCHIVO ADICIONAL: src/app/clientes/[id]/page.tsx
Agregar:
import { useSearchParams } from 'next/navigation';
const searchParams = useSearchParams();
const fromCases = searchParams.get('from') === 'casos';
const caseId = searchParams.get('caseId');

Modificar bot√≥n regreso:
<Link href={fromCases && caseId ? `/casos/${caseId}` : '/clientes'} ...>‚Üê</Link>

---------------------------------------------------
FIX 3: TAREAS ‚Üí NOTAS
---------------------------------------------------

ELIMINAR secci√≥n Tareas completa.
REEMPLAZAR con:

{/* Notas */}
<div className="bg-white rounded-xl shadow-sm border p-5">
  <h3 className="font-semibold mb-3">üìù Notas</h3>
  {editing ? (
    <textarea 
      value={form.notes} 
      onChange={e => setForm({...form, notes: e.target.value})}
      rows={4} 
      placeholder="Agregar notas del caso..."
      className="w-full px-3 py-2 border rounded-lg text-sm" 
    />
  ) : (
    <p className="text-slate-600 text-sm whitespace-pre-wrap">
      {caseData.notes || 'Sin notas'}
    </p>
  )}
</div>

---------------------------------------------------
FIX 4: ELIMINAR SECCI√ìN ACCIONES
---------------------------------------------------

ELIMINAR completamente el div de "Acciones" (IA se implementa despu√©s).
Bot√≥n "Eliminar caso" puede moverse a modo edici√≥n si se necesita.

---------------------------------------------------
FIX 5: FONDO CONSISTENTE
---------------------------------------------------

CAMBIAR: bg-slate-50 ‚Üí bg-stone-100

En:
- <div className="min-h-screen bg-stone-100">
- Estados loading/error tambi√©n

---------------------------------------------------
FIX 6: ELIMINAR BOT√ìN IA DEL HEADER
---------------------------------------------------

ELIMINAR:
<Link href={`/ai?caseId=${caseData.id}`} className="px-4 py-2 bg-blue-600...">ü§ñ Consultar IA</Link>

---------------------------------------------------
NOTA: VERCEL TOOLBAR
---------------------------------------------------

El icono settings es Vercel Toolbar (preview deployments).
Desactivar en vercel.json:
{ "toolbar": { "enabled": false } }

O Dashboard ‚Üí Settings ‚Üí Vercel Toolbar ‚Üí Disable

===================================================
COMMIT
===================================================

"fix: caso detail page - audiencias link, nav fix, notas, remove actions, consistent bg"

===================================================
FIN LEGAL-SOLUTIONS-FIX-001
===================================================


===================================================
LEGAL-PASO-SYNC
Import/Export y Sincronizaci√≥n PC ‚Üî M√≥vil
De: C1 (Sleepy) | Para: Cloud Claude
Fecha: 2026-01-18
===================================================

OBJETIVO: Hacer Legal Solutions funcional con sync entre dispositivos

CAPACIDAD:
- 10-20 expedientes
- 20-50 clientes  
- 100-200 escritos Word

---------------------------------------------------
ARQUITECTURA: IndexedDB
---------------------------------------------------

Usar IndexedDB en lugar de localStorage para almacenar:
- clients: datos de clientes
- cases: expedientes/casos
- documents: archivos Word/PDF en binario
- hearings: audiencias

Instalar: npm install idb

CREAR: src/lib/db.ts
- initDB() que crea stores con √≠ndices
- Permite almacenar archivos binarios grandes

---------------------------------------------------
COMPONENTE: SyncManager
---------------------------------------------------

CREAR: src/components/SyncManager.tsx

EXPORTAR:
1. Recopila todos los datos de IndexedDB
2. Convierte binarios a base64
3. Genera JSON y descarga como archivo
4. Nombre: legal-backup-YYYY-MM-DD.json

IMPORTAR:
1. Usuario selecciona archivo .json
2. Parsea y valida estructura
3. Convierte base64 a ArrayBuffer
4. Guarda todo en IndexedDB
5. Recarga p√°gina

---------------------------------------------------
COMPONENTE: DocumentUpload
---------------------------------------------------

CREAR: src/components/DocumentUpload.tsx

- Input file multiple
- Acepta: .doc, .docx, .pdf
- Lee archivo como ArrayBuffer
- Guarda en IndexedDB con metadata

---------------------------------------------------
COMPONENTE: DocumentList
---------------------------------------------------

CREAR: src/components/DocumentList.tsx

- Lista documentos del caso
- Icono seg√∫n tipo (üìÑ PDF, üìù Word)
- Bot√≥n descargar
- Bot√≥n eliminar
- Muestra tama√±o formateado

---------------------------------------------------
INTEGRACI√ìN
---------------------------------------------------

En src/app/page.tsx agregar:
import SyncManager from '@/components/SyncManager';
<SyncManager /> despu√©s de botones principales

En caso detalle agregar:
<DocumentUpload caseId={caseData.id} />
<DocumentList caseId={caseData.id} />

---------------------------------------------------
FLUJO DE USO
---------------------------------------------------

EXPORTAR (PC ‚Üí Cel):
1. Abrir app en PC
2. Click "Exportar Datos"
3. Descargar .json
4. Enviar por WhatsApp/email

IMPORTAR (Cel):
1. Abrir app en cel
2. Click "Importar Datos"
3. Seleccionar .json
4. Datos cargados!

---------------------------------------------------
CRITERIO DE √âXITO
---------------------------------------------------

[ ] IndexedDB inicializa
[ ] CRUD clientes en IndexedDB
[ ] CRUD casos en IndexedDB
[ ] Subir documento Word funciona
[ ] Descargar documento funciona
[ ] Export genera JSON completo
[ ] Import carga datos correctamente
[ ] Funciona en m√≥vil (PWA)
[ ] Funciona en PC
[ ] Datos persisten entre sesiones

===================================================
COMMIT
===================================================

"feat: add IndexedDB storage, document upload, import/export sync"

===================================================
FIN LEGAL-PASO-SYNC
===================================================
